{"Mod":{"name":"Acolyte Quest","author":"voxal","description":"","titleLeft":"Acolyte","titleRight":"Quest","subtitleLeft":"Goblin","subtitleRight":"Hideout","private":false},"Icons":{"hearts":{"path":"M480.25 156.355c0 161.24-224.25 324.43-224.25 324.43S31.75 317.595 31.75 156.355c0-91.41 70.63-125.13 107.77-125.13 77.65 0 116.48 65.72 116.48 65.72s38.83-65.73 116.48-65.73c37.14.01 107.77 33.72 107.77 125.14z","credit":"https://game-icons.net/1x1/skoll/hearts.html"}},"Spells":{"safe_health":{"id":"safe_health","name":"115 Health","description":"Your health is based on your level.","passive":true,"untargeted":true,"cooldown":1,"buffs":[{"type":"armor","passive":true,"proportion":-0.1281371469409145}],"icon":"hearts","color":"#d0021b","action":"buff"},"ai_health":{"id":"ai_health","description":"DO NOT USE THIS SPELL! YOU WILL NOT BE REWARDED WITH EXP","passive":true,"untargeted":true,"cooldown":1,"buffs":[{"type":"armor","passive":true,"proportion":0.33333333333333326}],"icon":"hearts","color":"#d0021b","action":"buff"},"fireboom":{"id":"fireboom","name":"Fireboom [Lvl 1]","description":"It's slower than fireball - harder to aim, but does more damage. Takes 0.5 seconds to grow to full damage, so keep a little bit of distance for maximum effect.","action":"projectile","color":"#ff4400","icon":"burningDot","maxAngleDiffInRevs":0.01,"cooldown":90,"throttle":true,"projectile":{"density":5,"radius":0.005,"speed":0.23,"maxTicks":120,"damage":0,"categories":2,"expireAfterCursorTicks":0,"detonate":{"damage":21,"radius":0.036,"minImpulse":0.00015,"maxImpulse":0.00015,"renderTicks":10},"partialDetonateRadius":{"initialMultiplier":0.2,"ticks":60},"partialDamage":{"initialMultiplier":0.67,"ticks":30},"sound":"flamestrike","color":"#ff4400","renderers":[{"type":"bloom"},{"type":"reticule","color":"rgba(128, 32, 0, 0.1)","radius":0.04,"minRadius":0.036,"usePartialDamageMultiplier":true},{"type":"projectile","ticks":4,"vanish":1,"minGraphics":2},{"type":"projectile","ticks":18,"smoke":0.4,"fade":"#333"},{"type":"ray","ticks":18},{"type":"strike","ticks":18,"flash":true,"numParticles":5}]}},"voidRush":{"id":"voidRush","name":"Void Rush [Lvl 4]","description":"For 3 seconds, increase movement speed 58%, and also take 58% less damage from the void.","effects":[{"icon":"fas fa-briefcase-medical","title":"Cleanse","text":"Clears all positive and negative effects."},{"icon":"fas fa-clock","title":"Void recharge","text":"Cools down 2x faster when in the void."}],"untargeted":true,"maxAngleDiffInRevs":1,"cooldown":600,"throttle":false,"debuff":true,"buffs":[{"type":"movement","movementProportion":1.58,"maxTicks":180},{"type":"cooldown","cooldownRateModifier":-1,"spellId":"voidRush","maxTicks":180},{"type":"armor","proportion":-0.58,"source":"lava","maxTicks":180,"sound":"voidRush-lavaImmunity","render":{"color":"#8800ff","heroColor":true,"ticks":60,"emissionRadiusFactor":0,"particleRadius":0.0135,"decay":true,"alpha":0.3,"light":0.8,"glow":0.7,"shine":0.5,"bloom":0.03,"vanish":1}}],"icon":"sprint","color":"#8800ff","action":"buff"},"fireball":{"id":"fireball","name":"Fireball [Lvl 4]","description":"Quick cooldown and packs a punch. Good old trusty fireball.","action":"projectile","color":"#f80","icon":"thunderball","maxAngleDiffInRevs":0.01,"cooldown":90,"throttle":true,"projectile":{"density":25,"radius":0.003,"speed":0.6,"maxTicks":90,"damage":16,"lifeSteal":0,"categories":2,"sound":"fireball","soundHit":"standard","color":"#f80","renderers":[{"type":"bloom","radius":0.01},{"type":"ray","ticks":4},{"type":"projectile","ticks":10,"smoke":0.16},{"type":"strike","ticks":30,"flash":true,"numParticles":3}]}},"repulsor":{"id":"repulsor","name":"Repulsor","description":"Huge knockback, if your aim is good enough. Beware, the recoil from Repulsor knocks you back too.","action":"projectile","color":"#00ddff","icon":"lightningHelix","maxAngleDiffInRevs":0.01,"cooldown":540,"throttle":true,"chargeTicks":6,"recoil":0.49,"projectile":{"density":11,"radius":0.0025,"speed":1.05,"maxTicks":60,"collideWith":65535,"swappable":false,"damage":0,"sound":"lightning","color":"#00ddff","renderers":[{"type":"bloom","radius":0.05},{"type":"ray","intermediatePoints":true,"ticks":30,"vanish":1},{"type":"strike","ticks":15,"flash":true,"detonate":0.01,"numParticles":5,"speedMultiplier":0.2}]}},"safe_big":{"id":"safe_big","name":"Gluttony","description":"DO NOT CHANGE THIS SPELL! YOU WILL NOT BE REWARDED WITH EXP","passive":true,"untargeted":true,"cooldown":1,"buffs":[{"type":"mass","radius":0.014,"passive":true}],"icon":"dodging","color":"#6f0","action":"buff"},"ai_small":{"id":"ai_small","description":"DO NOT USE THIS SPELL! YOU WILL NOT BE REWARDED WITH EXP","passive":true,"untargeted":true,"cooldown":1,"buffs":[{"type":"mass","radius":0.01,"passive":true}],"icon":"dodging","color":"#6f0","action":"buff"},"safe":{"id":"safe","description":"DO NOT CHANGE THIS SPELL! YOU WILL NOT BE REWARDED WITH EXP","icon":"dodging","color":"#6f0","cooldown":1,"cancelChanneling":false,"action":"move"},"ai_dagger":{"id":"ai_dagger","description":"DO NOT USE THIS SPELL! YOU WILL NOT BE REWARDED WITH EXP","action":"projectile","color":"#8f0","icon":"thunderball","maxAngleDiffInRevs":0.01,"cooldown":90,"throttle":true,"projectile":{"density":25,"radius":0.003,"speed":0.6,"maxTicks":90,"damage":16,"lifeSteal":0,"categories":2,"sound":"fireball","soundHit":"standard","color":"#8f0","renderers":[{"type":"bloom","radius":0.01},{"type":"ray","ticks":1},{"type":"projectile","ticks":10,"smoke":0.15},{"type":"strike","ticks":30,"flash":true,"numParticles":3}]}},"ai_bow":{"id":"ai_bow","description":"DO NOT USE THIS SPELL! YOU WILL NOT BE REWARDED WITH EXP","action":"projectile","color":"#8f0","icon":"lightningHelix","maxAngleDiffInRevs":0.01,"cooldown":180,"throttle":true,"chargeTicks":6,"recoil":0.25,"projectile":{"density":3,"radius":0.0025,"speed":1.5,"maxTicks":60,"collideWith":65535,"swappable":false,"damage":10,"sound":"lightning","color":"#8f0","renderers":[{"type":"bloom","radius":0.05},{"type":"ray","intermediatePoints":true,"ticks":30,"vanish":1},{"type":"strike","ticks":15,"flash":true,"detonate":0.01,"numParticles":5,"speedMultiplier":0.2}]}}},"Choices":{"Keys":[{"btn":"health","barSize":0.5,"wheelSize":0.25},{"btn":"a","barSize":0.75,"wheelSize":0.5},null,{"btn":"q","barSize":1,"wheelSize":1},{"btn":"w","barSize":1,"wheelSize":1},{"btn":"attack0","barSize":1e-7,"wheelSize":1e-7},{"btn":"attack1","barSize":1e-7,"wheelSize":1e-7}],"Options":{"health":[["safe_health"],["ai_health"]],"a":[["voidRush"]],"q":[["fireball","fireboom"]],"w":[["repulsor"]],"e":{"$delete":true},"r":{"$delete":true},"f":{"$delete":true},"attack0":[["safe_big","ai_small"]],"attack1":[["safe","ai_dagger","ai_bow"]]}},"Code":"\nvar AI_TYPE = \"ai_dagger\";\n\nvar center = { x: 0.5, y: 0.5 };\n\nvar CloseEnoughDistance = 0.05;\nvar CloseEnoughRadians = 0.1 * Math.PI;\nvar MissRadius = 0.05;\nvar DodgeRadius = 0.15;\nvar SpellCastIntervalMilliseconds = 1000;\nvar SpellCastJitterMilliseconds = 500;\n\nvar TicksPerSecond = 60;\n\nvar HardReactionMilliseconds = 600;\nvar EasyReactionMilliseconds = 3000;\nvar ReactionMillisecondsLookup = { // Change the reaction time on certain spells\n    retarget: 200,\n};\n\nvar alreadyChosenSpells = false;\nvar nextSpell = 0;\n\n// See ai.contracts.ts:\n// input is InputContract - contains information about the current state of the world\n// output is OutputContract - an action you want to take in response to the world \nfunction act(input) {\n    // Want the bot to do nothing? Uncomment the line below (remove the //):\n    // return null;\n\n    var state = input.state;\n    var heroId = input.heroId;\n    var hero = state.heroes[heroId];\n    var cooldowns = input.cooldowns;\n    var settings = input.settings;\n    var difficulty = input.difficulty;\n\n    var opponent = findOpponent(state.heroes, heroId);\n    if (!(hero && opponent)) {\n        // Either we're dead, or everyone else is, nothing to do\n        return null;\n    }\n    \n    var action = null;\n    if (state.started) {\n        action =\n            recovery(state, hero, cooldowns)\n            || dodge(state, hero, cooldowns)\n            || castSpell(state, hero, opponent, cooldowns, settings)\n            || focus(hero, opponent)\n            || chase(state, hero, cooldowns, opponent)\n            || move(state, hero)\n            || face(state, hero, opponent)\n    } else {\n        action =\n            chooseSpells(settings)\n            || dodge(state, hero, cooldowns)\n            || move(state, hero)\n            || face(state, hero, opponent)\n    }\n\n    if (action) {\n        // Give the bot a reaction time otherwise it is OP\n        var reactionMilliseconds = ReactionMillisecondsLookup[action.spellId] || defaultReactionMilliseconds(difficulty);\n        action.delayMilliseconds = reactionMilliseconds;\n        return action;\n    } else {\n        return null;\n    }\n}\n\nfunction defaultReactionMilliseconds(difficulty) {\n    var alpha = Math.sqrt(difficulty);\n    return alpha * HardReactionMilliseconds + (1 - alpha) * EasyReactionMilliseconds;\n}\n\nfunction chooseSpells(settings) {\n    if (alreadyChosenSpells) {\n        return null;\n    }\n    alreadyChosenSpells = true;\n\n    var spells = {}\n\n    spells[\"health\"] = \"ai_health\"\n    spells[\"attack0\"] = \"ai_small\";\n    spells[\"attack1\"] = [\"ai_dagger\", \"ai_bow\"][Math.floor(Math.random() * 2)];\n\n    AI_TYPE = spells[\"attack1\"];\n\n    return { spells };\n}\n\nfunction randomSpells(settings) {\n\tvar keyBindings = {};\n\tvar allOptions = settings.Choices.Options;\n\tfor (var btn in allOptions) { // One of the buttons, e.g. Q or R\n        var options = allOptions[btn];\n\n        var spellIds = [];\n        for (var i = 0; i < options.length; ++i) {\n            var row = options[i];\n            for (var j = 0; j < row.length; ++j) {\n                var spellId = row[j];\n                spellIds.push(spellId);\n            }\n        }\n\n\t\tif (spellIds.length > 1) {\n\t\t\tkeyBindings[btn] = spellIds[Math.floor(Math.random() * spellIds.length)];\n\t\t}\n\t}\n\treturn keyBindings;\n}\n\nfunction findOpponent(heroes, myHeroId) {\n    var myHero = heroes[myHeroId];\n    if (!myHero) {\n        return null;\n    }\n\n    var choice = null;\n    var mostHealth = 0;\n    for (var heroId in heroes) {\n        var hero = heroes[heroId];\n\n        if (!hero.isEnemy) { continue; }\n\n        // Uncomment the line below to only target humans\n        if (hero.isBot) { continue; }\n\n        if (hero.health > mostHealth) {\n            // Target the enemy with the most health\n            mostHealth = hero.health;\n            choice = hero;\n        }\n    }\n    return choice;\n}\n\nfunction recovery(state, hero, cooldowns) {\n    if (hero.inside || state.radius <= 0) {\n        // No need to recover\n        return null;\n    }\n\n    return { spellId: \"move\", target: center };\n}\n\nfunction deflect(state, hero, cooldowns, projectile) {\n    var target = vectorMidpoint(hero.pos, projectile.pos);\n    var spellId = null;\n    if (cooldowns[\"shield\"] === 0) {\n        spellId = \"shield\";\n    } else if (cooldowns[\"icewall\"] === 0) {\n        spellId = \"icewall\";\n    } else if (cooldowns[\"saber\"] === 0) {\n        spellId = \"saber\";\n    } else if (cooldowns[\"dualSaber\"] === 0) {\n        spellId = \"dualSaber\";\n    } else if (cooldowns[\"meteor\"] === 0) {\n        spellId = \"meteor\";\n    } else if (cooldowns[\"meteorite\"] === 0) {\n        spellId = \"meteorite\";\n    } else if (cooldowns[\"whirlwind\"] === 0) {\n        spellId = \"whirlwind\";\n    } else if (cooldowns[\"phaseOut\"] === 0) {\n        spellId = \"phaseOut\";\n    } else {\n        spellId = null;\n    }\n\n    if (spellId) {\n        return { spellId, target };\n    } else {\n        return null;\n    }\n}\n\nfunction castSpell(state, hero, opponent, cooldowns, settings) {\n    if (!readyForNextSpell(hero)) {\n        return null;\n    }\n\n    var candidates = [];\n    for (var spellId in cooldowns) {\n        var readyToCast = !cooldowns[spellId];\n        var spell = settings.Spells[spellId];\n        var aiSpell = spellId.startsWith(\"ai_\");\n\n        if (spell\n            && readyToCast\n            && validAttack(state, hero, opponent, spell)\n            && aiSpell) {\n\n            candidates.push(spellId);\n        }\n    }\n\n    if (candidates.length > 0) {\n        var spellId = candidates[Math.floor(Math.random() * candidates.length)];\n        var action = { spellId, target: jitter(opponent.pos, MissRadius) };\n        if (action.spellId === spellId) {\n            updateNextSpellTime();\n        }\n        return action;\n    } else {\n        return null;\n    }\n}\n\nfunction validAttack(state, hero, opponent, spell) {\n    var opponentShielded = !!opponent.shieldTicksRemaining;\n\n    var distance = vectorDistance(hero.pos, opponent.pos);\n    if (spell.action === \"projectile\" || spell.action === \"spray\" || spell.action === \"retractor\" || spell.action === \"focus\" || spell.action === \"charge\") {\n        if (spell.id === \"swap\") { // Swap doesn't work as an attack\n            return false;\n        }\n        if (opponentShielded && !spell.projectile.detonate) { // Detonate spells can penetrate shields, nothing else can\n            return false;\n        }\n        if (spell.id === \"whip\") {\n            // Just keep casting Electroshock even if out of range\n            return true;\n        }\n\n        var range = spell.projectile.speed * spell.projectile.maxTicks / TicksPerSecond + opponent.radius;\n        return distance <= range;\n    } else if (spell.action === \"scourge\") {\n        var range = spell.detonate.radius + opponent.radius;\n        return distance <= range;\n    } else if (spell.id === \"blaze\") {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction readyForNextSpell(hero) {\n    return (\n        Date.now() >= nextSpell // Don't cast too fast\n        || !!hero.link // If linked to something, cast as many spells as possible\n    );\n}\n\nfunction updateNextSpellTime() {\n    nextSpell = Date.now() + SpellCastIntervalMilliseconds + Math.floor((Math.random() < 0.5 ? -1 : 1) * Math.random() * SpellCastJitterMilliseconds);\n}\n\nfunction jitter(target, missRadius) {\n    var radius = Math.random() * missRadius;\n    var angle = Math.random() * 2 * Math.PI;\n    return {\n        x: target.x + radius * Math.cos(angle),\n        y: target.y + radius * Math.sin(angle),\n    };\n}\n\nfunction focus(hero, opponent) { // When using a spell (e.g. Acolyte Beam, Spirit Missile) - ensure we are focusing the enemy, otherwise we will miss\n    if (hero.casting) {\n        if (hero.casting.spellId === \"blast\" || hero.casting.spellId === \"retractor\" || hero.casting.spellId === \"rocket\") {\n            // Have to release or it won't fire\n            return { spellId: hero.casting.spellId, release: true, target: opponent.pos };\n        } else if (hero.casting.spellId === \"saber\" || hero.casting.spellId === \"dualSaber\") {\n            // Don't focus the lightsaber, just swish it around\n            return { spellId: \"retarget\", target: vectorPlus(hero.pos, vectorFromAngle(hero.heading + Math.PI / 2)) };\n        } else if (hero.casting.spellId === \"grapple\") {\n            // Throw away to the right (TODO: be smarter about this)\n            return { spellId: hero.casting.spellId, release: true, target: vectorPlus(hero.pos, vectorFromAngle(hero.heading + Math.PI / 2)) };\n        } else if (hero.casting.spellId === \"halo\") {\n            return { spellId: \"move\", target: opponent.pos };\n        } else {\n            return { spellId: \"retarget\", target: opponent.pos };\n        }\n    } else {\n        return null;\n    }\n}\n\nfunction chase(state, hero, cooldowns, opponent) {\n    if (\"whip\" in cooldowns) {\n        // Got to get within range when using Electroshock\n        var target = vectorMidpoint(hero.pos, opponent.pos);\n        return { spellId: \"move\", target };\n    } else {\n        return null;\n    }\n}\n\nfunction move(state, hero) {\n    var centroid = { x: 0, y: 0 };\n    var numOpponents = 0;\n    for (var heroId in state.heroes) {\n        if (heroId === hero.id) {\n            continue; // Ignore self\n        }\n\n        var opponent = state.heroes[heroId];\n        centroid.x += opponent.pos.x;\n        centroid.y += opponent.pos.y;\n\n        ++numOpponents;\n    }\n    centroid.x /= numOpponents;\n    centroid.y /= numOpponents;\n\n    if (!numOpponents) {\n        return;\n    }\n\n    var offset = vectorNegate(vectorDiff(centroid, center)); // Move to the opposite side of the arena\n    var targetDistance = state.radius * 0.33; // Closer to center than edge (for polygonal maps)\n    var target = vectorPlus(center, vectorRelengthen(offset, targetDistance));\n\n    var distanceToTarget = vectorDistance(hero.pos, target);\n    if (distanceToTarget <= CloseEnoughDistance) {\n        // Close enough - don't send any action so the game can sleep while waiting for players\n        return null;\n    }\n\n    return { spellId: \"move\", target };\n}\n\nfunction face(state, hero, opponent) {\n    var target = opponent.pos;\n    var targetAngle = vectorAngle(vectorDiff(opponent.pos, hero.pos));\n    var angleDelta = vectorAngleDelta(hero.heading, targetAngle);\n    if (Math.abs(angleDelta) <= CloseEnoughRadians) {\n        return null;\n    }\n\n    return { spellId: \"retarget\", target };\n}\n\nfunction dodge(state, hero, cooldowns) {\n    for (var projectileId in state.projectiles) {\n        var projectile = state.projectiles[projectileId];\n        if (projectile.ownerId === hero.id) {\n            // This is my own projectile\n            continue;\n        }\n\n        if (projectile.spellId === \"halo\") {\n            // Halo is never coming for us, it orbits around its owner\n            continue;\n        }\n\n        var diff = vectorDiff(hero.pos, projectile.pos);\n        var distancePerTimeStep = vectorDot(projectile.velocity, vectorUnit(diff));\n        if (distancePerTimeStep <= 0) {\n            // Not coming towards us\n            continue;\n        }\n\n        var timeToCollision = vectorLength(diff) / distancePerTimeStep;\n        if (timeToCollision <= 0 || timeToCollision >= 30) {\n            // Not coming towards us or too far away\n            continue;\n        }\n\n        var collisionPoint = vectorPlus(projectile.pos, vectorMultiply(projectile.velocity, timeToCollision));\n        var distanceToCollision = vectorDistance(collisionPoint, hero.pos);\n        var dodgeRadius = Math.max(DodgeRadius, projectile.radius) + hero.radius;\n        if (distanceToCollision > dodgeRadius) {\n            // Won't hit us\n            continue;\n        }\n\n        var deflectAction = deflect(state, hero, cooldowns, projectile);\n        if (deflectAction) {\n            return deflectAction;\n        }\n\n        // Run away from collision point\n        var direction = vectorUnit(vectorNegate(vectorDiff(collisionPoint, hero.pos)));\n        var step = vectorMultiply(direction, dodgeRadius);\n        var target = vectorPlus(hero.pos, step);\n        return { spellId: \"move\", target };\n    }\n    return null;\n}\n\nfunction vectorDiff(to, from) {\n    return { x: to.x - from.x, y: to.y - from.y };\n}\n\nfunction vectorLength(vector) {\n    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n}\n\nfunction vectorDistance(from, to) {\n    return vectorLength(vectorDiff(from, to));\n}\n\nfunction vectorUnit(vec) {\n    var length = vectorLength(vec);\n    return length === 0 ? vec : vectorMultiply(vec, 1 / length);\n}\n\nfunction vectorPlus(from, offset) {\n    return { x: from.x + offset.x, y: from.y + offset.y };\n}\n\nfunction vectorMultiply(vec, multiplier) {\n    return { x: vec.x * multiplier, y: vec.y * multiplier };\n}\n\nfunction vectorRelengthen(vec, length) {\n    return vectorMultiply(vectorUnit(vec), length);\n}\n\nfunction vectorNegate(vec) {\n    return vectorMultiply(vec, -1);\n}\n\nfunction vectorDot(a, b) {\n    return (a.x * b.x) + (a.y * b.y);\n}\n\nfunction vectorMidpoint(a, b) {\n    var diff = vectorDiff(b, a);\n    return vectorPlus(a, vectorMultiply(diff, 0.5));\n}\n\nfunction vectorFromAngle(angle) {\n\treturn { x: Math.cos(angle), y: Math.sin(angle) };\n}\n\nfunction vectorAngle(vec) {\n    return Math.atan2(vec.y, vec.x);\n}\n\nfunction vectorAngleDelta(currentAngle, targetAngle) {\n\tvar delta = targetAngle - currentAngle;\n\twhile (delta > Math.PI) {\n\t\tdelta -= 2 * Math.PI;\n\t}\n\twhile (delta < -Math.PI) {\n\t\tdelta += 2 * Math.PI;\n\t}\n\treturn delta;\n}\n\n// See ai.contracts.ts: Must return a BotContract\nreturn { act };\n","Matchmaking":{"MinBots":2,"MaxBots":3},"Hero":{"Radius":0.01},"World":{"BotName":"Goblin"},"Visuals":{"BotColor":"#3d8038"}}